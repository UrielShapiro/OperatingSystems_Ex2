        -:    0:Source:Q6/mync.cpp
        -:    0:Graph:mync.gcno
        -:    0:Data:mync.gcda
        -:    0:Runs:51
        -:    1:#include <iostream>
        -:    2:#include <cstring>
        -:    3:#include <unistd.h>
        -:    4:#include <sys/wait.h>
        -:    5:#include <sys/socket.h>
        -:    6:#include <sys/types.h>
        -:    7:#include <netinet/in.h>
        -:    8:#include <arpa/inet.h>
        -:    9:#include <netdb.h>
        -:   10:#include <vector>
        -:   11:#include <sys/un.h>
        -:   12:#include <threads.h>
        -:   13:#include <memory>
        -:   14:#include <signal.h>
        -:   15:#include <limits.h>
        -:   16:
        -:   17:// the maximum length of a string representing a port
        -:   18:constexpr size_t MAX_PORT_SIZE = 6;
        -:   19:// the maximum length of a string representing a hostname or IP
        -:   20:constexpr size_t MAX_HOSTNAME_SIZE = std::max(INET_ADDRSTRLEN, HOST_NAME_MAX);
        -:   21:// used when there is no -e option, currently stored on stack so avoid sizes too large
        -:   22:constexpr size_t PIPER_BUFFER_SIZE = 1024;
        -:   23:
        -:   24:// a class for something that needs to be cleaned up on exit
        -:   25:class Cleanup
        -:   26:{
        -:   27:public:
        -:   28:    // the clean up to be performed
        -:   29:    virtual void cleanup() = 0;
        -:   30:};
        -:   31:
        -:   32:// a socket that needs to be closed
        -:   33:class SockCleanup : public Cleanup
        -:   34:{
        -:   35:    int sockfd;
        -:   36:
        -:   37:public:
       18:   38:    SockCleanup(int fd) : sockfd(fd) {}
       17:   39:    void cleanup() override
        -:   40:    {
       17:   41:        close(sockfd);
       17:   42:    }
        -:   43:};
        -:   44:
        -:   45:// a UDS bind that needs to be unlinked
        -:   46:class UDSCleanup : public Cleanup
        -:   47:{
        -:   48:    // memory is owned by this class
        -:   49:    char *filename;
        -:   50:
        -:   51:public:
        2:   52:    UDSCleanup(char *file) : filename(strdup(file)) {}
        2:   53:    void cleanup() override
        -:   54:    {
        -:   55:        // unlink the socket
        2:   56:        unlink(filename);
        -:   57:        // free the owned memory
        2:   58:        free(filename);
        -:   59:        // prevent dangling pointer
        2:   60:        filename = NULL;
        2:   61:    }
        -:   62:};
        -:   63:
        -:   64:// the vector of objects to be cleaned up
        -:   65:std::vector<std::unique_ptr<Cleanup>> to_cleanup;
        -:   66:
        2:   67:int open_dgram_client(sockaddr *server_addr)
        -:   68:{
        2:   69:    int client_sock = socket(server_addr->sa_family, SOCK_DGRAM, 0);
        2:   70:    if (client_sock < 0)
        -:   71:    {
    #####:   72:        throw std::runtime_error("Error opening a UDP client socket: " + std::string(strerror(errno)));
        -:   73:    }
        -:   74:    // add the socket to the cleanup
        2:   75:    to_cleanup.push_back(std::make_unique<SockCleanup>(SockCleanup(client_sock)));
        -:   76:    // find the proper length according to the family
        -:   77:    socklen_t server_addr_len;
        2:   78:    if (server_addr->sa_family == AF_UNIX)
        -:   79:    {
        1:   80:        server_addr_len = sizeof(struct sockaddr_un);
        -:   81:    }
        1:   82:    else if (server_addr->sa_family == AF_INET)
        -:   83:    {
        1:   84:        server_addr_len = sizeof(struct sockaddr_in);
        -:   85:    }
        -:   86:    else
        -:   87:    {
    #####:   88:        throw std::runtime_error("Unkown sa_family");
        -:   89:    }
        2:   90:    if (connect(client_sock, (struct sockaddr *)server_addr, server_addr_len) < 0)
        -:   91:    {
    #####:   92:        throw std::runtime_error("Error connecting to the server socket: " + std::string(strerror(errno)));
        -:   93:    }
        -:   94:
        2:   95:    return client_sock;
        -:   96:}
        -:   97:
        6:   98:int open_stream_client(sockaddr *server_addr)
        -:   99:{
        6:  100:    int client_sock = socket(server_addr->sa_family, SOCK_STREAM, 0);
        6:  101:    if (client_sock < 0)
        -:  102:    {
    #####:  103:        throw std::runtime_error("Error opening a client socket: " + std::string(strerror(errno)));
        -:  104:    }
        -:  105:    // add the socket to the cleanup
        6:  106:    to_cleanup.push_back(std::make_unique<SockCleanup>(SockCleanup(client_sock)));
        -:  107:    // find the proper length accrding to the family
        -:  108:    socklen_t server_addr_len;
        6:  109:    if (server_addr->sa_family == AF_UNIX)
        -:  110:    {
        2:  111:        server_addr_len = sizeof(struct sockaddr_un);
        -:  112:    }
        4:  113:    else if (server_addr->sa_family == AF_INET)
        -:  114:    {
        4:  115:        server_addr_len = sizeof(struct sockaddr_in);
        -:  116:    }
        -:  117:    else
        -:  118:    {
    #####:  119:        throw std::runtime_error("Unkown sa_family");
        -:  120:    }
        6:  121:    if (connect(client_sock, (struct sockaddr *)server_addr, server_addr_len) < 0)
        -:  122:    {
        1:  123:        throw std::runtime_error("Error connecting to the server socket: " + std::string(strerror(errno)));
        -:  124:    }
        -:  125:
        5:  126:    return client_sock;
        -:  127:}
        -:  128:
        4:  129:int open_stream_server(sockaddr *server_address)
        -:  130:{
        4:  131:    int server_sock = socket(server_address->sa_family, SOCK_STREAM, 0);
        4:  132:    if (server_sock < 0)
        -:  133:    {
    #####:  134:        throw std::runtime_error("Error opening a server stream: " + std::string(strerror(errno)));
        -:  135:    }
        -:  136:    // add the server socket to the cleanup
        4:  137:    to_cleanup.push_back(std::make_unique<SockCleanup>(SockCleanup(server_sock)));
        -:  138:
        4:  139:    if (server_address->sa_family == AF_UNIX)
        -:  140:    {
        -:  141:        // add the UDS socket to be unbinded
        1:  142:        to_cleanup.push_back(std::make_unique<UDSCleanup>(((sockaddr_un *)server_address)->sun_path));
        -:  143:    }
        -:  144:    else
        -:  145:    {
        3:  146:        int reuse = 1;
        3:  147:        if (setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse)) < 0)
        -:  148:        {
    #####:  149:            throw std::runtime_error("Error setting socket option SO_REUSEADDR: " + std::string(strerror(errno)));
        -:  150:        }
        -:  151:    }
        4:  152:    if (bind(server_sock, (struct sockaddr *)server_address, sizeof(*server_address)) < 0)
        -:  153:    {
    #####:  154:        throw std::runtime_error("Error binding the server socket: " + std::string(strerror(errno)));
        -:  155:    }
        4:  156:    if (listen(server_sock, 1) < 0)
        -:  157:    {
    #####:  158:        throw std::runtime_error("Error listening on server socket: " + std::string(strerror(errno)));
        -:  159:    }
        -:  160:
        4:  161:    int client_socket = accept(server_sock, NULL, NULL);
        4:  162:    if (client_socket < 0)
        -:  163:    {
    #####:  164:        throw std::runtime_error("Error accepting client: " + std::string(strerror(errno)));
        -:  165:    }
        -:  166:    // add the client socket to the cleanup
        4:  167:    to_cleanup.push_back(std::make_unique<SockCleanup>(SockCleanup(client_socket)));
        -:  168:
        4:  169:    return client_socket;
        -:  170:}
        -:  171:
        2:  172:int open_dgram_server(sockaddr *server_address)
        -:  173:{
        2:  174:    int server_sock = socket(server_address->sa_family, SOCK_DGRAM, 0);
        2:  175:    if (server_sock < 0)
        -:  176:    {
    #####:  177:        throw std::runtime_error("Error opening a datagram server socket: " + std::string(strerror(errno)));
        -:  178:    }
        -:  179:    // add the server socket to the cleanup
        2:  180:    to_cleanup.push_back(std::make_unique<SockCleanup>(SockCleanup(server_sock)));
        -:  181:
        2:  182:    if (server_address->sa_family == AF_UNIX)
        -:  183:    {
        -:  184:        // add the UDS socket to be unbinded
        1:  185:        to_cleanup.push_back(std::make_unique<UDSCleanup>(((sockaddr_un *)server_address)->sun_path));
        -:  186:    }
        -:  187:    else
        -:  188:    {
        1:  189:        int reuse = 1;
        1:  190:        if (setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse)) < 0)
        -:  191:        {
    #####:  192:            throw std::runtime_error("Error setting socket option SO_REUSEADDR: " + std::string(strerror(errno)));
        -:  193:        }
        -:  194:    }
        2:  195:    if (bind(server_sock, (struct sockaddr *)server_address, sizeof(*server_address)) < 0)
        -:  196:    {
    #####:  197:        throw std::runtime_error("Error binding the datagram server socket: " + std::string(strerror(errno)));
        -:  198:    }
        -:  199:
        2:  200:    return server_sock;
        -:  201:}
        -:  202:
       37:  203:void print_usage(char *program_name)
        -:  204:{
       37:  205:    std::cerr << "Usage: " << program_name << " [-e \"<command>\"] [-(i|o|b) <connection specifier>]" << std::endl
       37:  206:              << "Use at most one specifier per direction, i.e. either -b alone or at most one of -i and -o each" << std::endl
       37:  207:              << "Valid connection specifiers:" << std::endl
       37:  208:              << "\tTCP: Use TCPS<port> for server or TCPC<hostname or IP>,<port> for client" << std::endl
       37:  209:              << "\tUDP: Use UDPS<port> for server or UDPC<hostname or IP>,<port> for client" << std::endl
       37:  210:              << "\tUnix Domain Socket: Use UDSS<socket type><socket path> for server or UDSC<socket type><socket path> for client" << std::endl
       37:  211:              << "\t\tValid socket types: \'S\' for stream socket, \'D\' for datagram socket" << std::endl;
       37:  212:}
        -:  213:
        -:  214:enum HostType
        -:  215:{
        -:  216:    SERVER,
        -:  217:    CLIENT
        -:  218:};
        -:  219:
        -:  220:// a struct representing a connection of the program
        -:  221:typedef struct
        -:  222:{
        -:  223:    // the sockaddr is a union to ensure enough space to store any possible value
        -:  224:    union
        -:  225:    {
        -:  226:        struct sockaddr addr;
        -:  227:        // the data must have enough space for either sockaddr_un or sockaddr_in
        -:  228:        uint8_t addr_data[std::max(sizeof(struct sockaddr_un), sizeof(struct sockaddr_in))];
        -:  229:    };
        -:  230:    // the socket_type, according to socket(2) parameter type
        -:  231:    int socktype;
        -:  232:    HostType host_type;
        -:  233:} connection;
        -:  234:
        -:  235:// this function parses a connection specifier argument	into a connection struct
       49:  236:connection *parse_connection(char *arg)
        -:  237:{
        -:  238:    // connection specifier must have at least 4 characters (e.g. UDPC)
       49:  239:    if (strlen(arg) < 4)
        -:  240:    {
        3:  241:        throw std::invalid_argument("Argument is too short");
        -:  242:    }
        -:  243:    // initialize hints to be sent to getaddrinfo
        -:  244:    struct addrinfo hints;
       46:  245:    memset(&hints, 0, sizeof(hints));
        -:  246:
        -:  247:    // allocate result
       46:  248:    connection *result = (connection *)malloc(sizeof(connection));
       46:  249:    memset(result, 0, sizeof(*result));
        -:  250:
        -:  251:    // check specifier type
       46:  252:    if (strncmp(arg, "TCP", 3) == 0)
        -:  253:    {
        -:  254:        // set result socktype
       23:  255:        result->socktype = SOCK_STREAM;
        -:  256:        // set hints
       23:  257:        hints.ai_socktype = SOCK_STREAM;
       23:  258:        hints.ai_protocol = IPPROTO_TCP;
        -:  259:    }
       23:  260:    else if (strncmp(arg, "UDP", 3) == 0)
        -:  261:    {
        -:  262:        // set result socktype
        9:  263:        result->socktype = SOCK_DGRAM;
        -:  264:        // set hints
        9:  265:        hints.ai_socktype = SOCK_DGRAM;
        9:  266:        hints.ai_protocol = IPPROTO_UDP;
        -:  267:    }
       14:  268:    else if (strncmp(arg, "UDS", 3) == 0)
        -:  269:    {
        -:  270:        // UDS specifier must have at least 5 characters (e.g. UDSCD)
       13:  271:        if (strlen(arg) < 5)
        -:  272:        {
        1:  273:            free(result);
        1:  274:            throw std::invalid_argument("UDS argument is too short");
        -:  275:        }
        -:  276:        // check socket type and set in result
       12:  277:        if (arg[4] == 'S')
        5:  278:            result->socktype = SOCK_STREAM;
        7:  279:        else if (arg[4] == 'D')
        6:  280:            result->socktype = SOCK_DGRAM;
        -:  281:        else
        -:  282:        {
        1:  283:            free(result);
        1:  284:            throw std::invalid_argument("Unkown UDS type");
        -:  285:        }
        -:  286:        // check host type and set in result
       11:  287:        if (arg[3] == 'S')
        5:  288:            result->host_type = SERVER;
        6:  289:        else if (arg[3] == 'C')
        5:  290:            result->host_type = CLIENT;
        -:  291:        else
        -:  292:        {
        1:  293:            free(result);
        1:  294:            throw std::invalid_argument("Unkown connection type specifier");
        -:  295:        }
        -:  296:        // make a pointer to the result address as a sockaddr_un
       10:  297:        struct sockaddr_un *addr_unix = (struct sockaddr_un *)&result->addr;
        -:  298:        // make sure the length of the string after the first 5 chars is not too large
       10:  299:        if (strlen(arg + 5) + 1 > sizeof(addr_unix->sun_path)) // + 1 for null terminator
        -:  300:        {
        1:  301:            free(result);
        1:  302:            throw std::invalid_argument("UDS path is too long");
        -:  303:        }
        -:  304:        // copy the path from arg + 5 to the sun_path
        9:  305:        strcpy(addr_unix->sun_path, arg + 5);
        -:  306:        // set the family
        9:  307:        addr_unix->sun_family = AF_UNIX;
        -:  308:        // we are done with UDS, we can return
        9:  309:        return result;
        -:  310:    }
        -:  311:    else
        -:  312:    {
        1:  313:        free(result);
        1:  314:        throw std::invalid_argument("Unkown protocol specifier");
        -:  315:    }
        -:  316:    // at this point we know the specifier is either TCP or UDP, the fields were set accordingly
        -:  317:    // we just need to parse the rest
        -:  318:
        -:  319:    // initialize pointers to the hostname and the port (we make new memory for the port to copy into)
       32:  320:    char *hostname = NULL, *port = (char *)malloc(MAX_PORT_SIZE);
        -:  321:
        -:  322:    // set hints
       32:  323:    hints.ai_family = AF_INET;        // TCP and UDP over IPv4
       32:  324:    hints.ai_flags |= AI_NUMERICSERV; // service will be numeric (port number)
        -:  325:
       32:  326:    if (arg[3] == 'S') // a server specifier is of format (TCP|UDP)S<port>
        -:  327:    {
        -:  328:        // make sure there is some port
       11:  329:        if (strlen(arg + 4) < 1)
        -:  330:        {
        1:  331:            free(port);
        1:  332:            throw std::invalid_argument("No port provided in server specifier");
        -:  333:        }
        -:  334:        // copy it into the port string
       10:  335:        strncpy(port, arg + 4, MAX_PORT_SIZE);
        -:  336:
        -:  337:        // make sure it is numeric, try to parse into a number and make sure it is not negative
        -:  338:        try
        -:  339:        {
       12:  340:            if (std::stoi(port) < 0)
        1:  341:                throw std::exception();
        -:  342:        }
        4:  343:        catch (const std::exception &e)
        -:  344:        {
        2:  345:            free(port);
        2:  346:            throw std::invalid_argument("Invalid port number provided in server specifier");
        -:  347:        }
        -:  348:
        8:  349:        hints.ai_flags |= AI_PASSIVE; // to get server address from getaddrinfo
        -:  350:
        -:  351:        // set type to server
        8:  352:        result->host_type = SERVER;
        -:  353:    }
       21:  354:    else if (arg[3] == 'C') // a client specifier is of format (TCP|UDP)C<hostname or IP>,<port>
        -:  355:    {
        -:  356:        // pointer to the comma (that should exist)
       19:  357:        char *comma = arg + 4;
        -:  358:        // find the comma
      215:  359:        while (*comma != '\0' && *comma != ',')
      196:  360:            comma += 1;
        -:  361:        // if reached null, there was no comma
       19:  362:        if (*comma == '\0')
        -:  363:        {
        2:  364:            free(port);
        2:  365:            throw std::invalid_argument("No comma seperator in client specifier");
        -:  366:        }
        -:  367:        // make sure there is something after the comma
       17:  368:        if (strlen(comma + 1) < 1)
        -:  369:        {
        1:  370:            free(port);
        1:  371:            throw std::invalid_argument("No port provided in client specifier");
        -:  372:        }
        -:  373:        // copy the port (1 char after the comma until the end) into the buffer
       16:  374:        strncpy(port, comma + 1, MAX_PORT_SIZE);
        -:  375:
        -:  376:        // make sure it is numeric, try to parse into a number and make sure it is not negative
        -:  377:        try
        -:  378:        {
       16:  379:            std::stoi(port);
        -:  380:        }
    =====:  381:        catch (const std::exception &e)
        -:  382:        {
    =====:  383:            free(port);
    =====:  384:            throw std::invalid_argument("Invalid port number provided in client specifier");
        -:  385:        }
        -:  386:
        -:  387:        // if the comma is the 5th char, there is no IP or hostname
       16:  388:        if (comma == arg + 4)
        -:  389:        {
        1:  390:            free(port);
        1:  391:            throw std::invalid_argument("No IP or hostname provided in client specifier");
        -:  392:        }
        -:  393:        // if the difference is too large, the hostname provided is too long
       15:  394:        if ((size_t)(comma - (arg + 4)) > MAX_HOSTNAME_SIZE)
        -:  395:        {
    #####:  396:            free(port);
    #####:  397:            throw std::invalid_argument("Hostname or IP is too long");
        -:  398:        }
        -:  399:
        -:  400:        // allocate memory for the hostname
       15:  401:        hostname = (char *)malloc(MAX_HOSTNAME_SIZE + 1); // + 1 for null terminator
        -:  402:
        -:  403:        // copy the hostname into the buffer, should be (comma - (arg + 4)) chars
       15:  404:        strncpy(hostname, arg + 4, comma - (arg + 4));
        -:  405:        // put null terminator in hostname buffer
       15:  406:        hostname[comma - (arg + 4)] = '\0';
        -:  407:
        -:  408:        // set as client
       15:  409:        result->host_type = CLIENT;
        -:  410:    }
        -:  411:    else
        -:  412:    {
        2:  413:        throw std::invalid_argument("Unkown connection type specifier");
        -:  414:    }
        -:  415:
        -:  416:    // initialize return of getaddrinfo
        -:  417:    struct addrinfo *addrinfo_ret;
        -:  418:    // call it with the accumulated hints, hostname, and port, save result into addrinfo_ret
       23:  419:    int error = getaddrinfo(hostname, port, &hints, &addrinfo_ret);
        -:  420:    // check for errors
       23:  421:    if (error != 0)
        -:  422:    {
        3:  423:        free(port);
        3:  424:        free(hostname);
        3:  425:        throw std::runtime_error("Error getting address info: " + std::string(gai_strerror(error))); // gai = getaddrinfo
        -:  426:    }
        -:  427:
        -:  428:    // copy the return (in ai_addr) into the addr_data of the result (which means result->addr is now a valid sockaddr_in)
       20:  429:    memcpy(&result->addr_data, addrinfo_ret->ai_addr, sizeof(result->addr_data));
        -:  430:
        -:  431:    // free the returned struct
       20:  432:    freeaddrinfo(addrinfo_ret);
       20:  433:    free(port);
       20:  434:    free(hostname);
        -:  435:
        -:  436:    // return the result
       20:  437:    return result;
        -:  438:}
        -:  439:
        -:  440:// factory method to set up a connection, takes a pointer to a connection struct and returns a file descriptor over which the communication can occur
       14:  441:int setup_connection(connection *conn)
        -:  442:{
       14:  443:    switch (conn->socktype)
        -:  444:    {
       10:  445:    case SOCK_STREAM:
       10:  446:        if (conn->host_type == SERVER)
        4:  447:            return open_stream_server(&conn->addr);
        -:  448:        else
        6:  449:            return open_stream_client(&conn->addr);
        4:  450:    case SOCK_DGRAM:
        4:  451:        if (conn->host_type == SERVER)
        2:  452:            return open_dgram_server(&conn->addr);
        -:  453:        else
        2:  454:            return open_dgram_client(&conn->addr);
    #####:  455:    default:
    #####:  456:        throw std::runtime_error("Invalid connection type");
        -:  457:    }
        -:  458:}
        -:  459:
        -:  460:// conforms to thrd_start_t to run multithreaded
        -:  461:// this functions takes a int[2] = {read_fd, write_fd} and pipes information from read_fd to write_fd until either closes
        2:  462:int piper(void *arg)
        -:  463:{
        -:  464:    // extract two fds from the argument
        2:  465:    int *fds = (int *)arg;
        2:  466:    int read_fd = fds[0], write_fd = fds[1];
        -:  467:    // create a buffer for communicated data
        -:  468:    char buffer[PIPER_BUFFER_SIZE];
        -:  469:    while (true)
        -:  470:    {
        -:  471:        // read data into the buffer
        4:  472:        ssize_t n_read = read(read_fd, buffer, sizeof(buffer));
        -:  473:        // check for error
        4:  474:        if (n_read < 0)
        -:  475:        {
    #####:  476:            return 1;
        -:  477:        }
        -:  478:        // check for close
        4:  479:        if (n_read == 0)
        -:  480:        {
        2:  481:            return 0;
        -:  482:        }
        -:  483:        // write the data
        2:  484:        ssize_t n_written = write(write_fd, buffer, n_read);
        -:  485:        // check for error
        2:  486:        if (n_written < 0)
        -:  487:        {
    #####:  488:            return 1;
        -:  489:        }
        -:  490:        // check for close
        2:  491:        if (n_written == 0)
        -:  492:        {
    #####:  493:            return 0;
        -:  494:        }
        -:  495:        if (n_written < n_read)
        -:  496:        {
        -:  497:            // TODO: write more?
        -:  498:        }
        2:  499:    }
        -:  500:    return 0;
        -:  501:}
        -:  502:
        -:  503:// cleans up all accumulated Cleanups from to_cleanup, should be performed on SIGALRM
    #####:  504:void cleanup_all(int signum)
        -:  505:{
        -:  506:    (void)signum; // don't care which signal, should only be SIGALRM anyway
        -:  507:
        -:  508:    // go through the pointers
    #####:  509:    for (auto &cu : to_cleanup)
        -:  510:    {
        -:  511:        // clean up each one
    #####:  512:        cu->cleanup();
        -:  513:    }
    #####:  514:    kill(0, SIGALRM); // kill all living children
    #####:  515:    exit(0);
        -:  516:}
        -:  517:
       51:  518:int main(int argc, char *argv[])
        -:  519:{
        -:  520:    // set the action of SIGALRM to be cleanup_all
        -:  521:    {
       51:  522:        struct sigaction cleanup_action = {};
       51:  523:        cleanup_action.sa_handler = &cleanup_all;
       51:  524:        sigaction(SIGALRM, &cleanup_action, NULL);
        -:  525:    }
        -:  526:
        -:  527:    // pointers to the connections
       51:  528:    connection *input = NULL;
       51:  529:    connection *output = NULL;
       51:  530:    connection *both = NULL;
        -:  531:
        -:  532:    // the command to run (if -e is provided)
       51:  533:    char *command = NULL;
        -:  534:    char c;
        -:  535:    // get an option
       83:  536:    while ((c = getopt(argc, argv, "e:i:o:b:t:")) != -1)
        -:  537:    {
       69:  538:        switch (c)
        -:  539:        {
        1:  540:        case 't':
        -:  541:            // -t option, set an alarm and make sure it is numeric
        -:  542:            try
        -:  543:            {
        -:  544:                // parse the timeout
       3*:  545:                long timeout = std::stol(optarg);
        -:  546:                // make sure it is positive
    #####:  547:                if (timeout <= 0)
    #####:  548:                    throw std::invalid_argument("Can't have non-positive timeout");
        -:  549:                // set an alarm
    #####:  550:                alarm(timeout);
        -:  551:            }
        1:  552:            catch (const std::exception &e)
        -:  553:            {
        -:  554:                // on error, either print the explanation or a custom explanation for stol
        1:  555:                std::cerr << "Error in timeout argument: " << (strcmp(e.what(), "stol") == 0 ? "Please enter a number" : e.what()) << std::endl;
        1:  556:                print_usage(argv[0]);
        1:  557:                return 1;
        -:  558:            }
    #####:  559:            break;
        -:  560:
       12:  561:        case 'e':
        -:  562:            // -e option, copy the string into command
       12:  563:            command = optarg;
       12:  564:            break;
        -:  565:
       15:  566:        case 'i':
       15:  567:            if (input != NULL)
        -:  568:            {
        1:  569:                print_usage(argv[0]);
        1:  570:                std::cerr << "Cannot have double specifier for input" << std::endl;
        1:  571:                free(output);
        1:  572:                free(input);
        1:  573:                free(both);
        1:  574:                return 1;
        -:  575:            }
       14:  576:            if (both != NULL)
        -:  577:            {
        1:  578:                print_usage(argv[0]);
        1:  579:                std::cerr << "Cannot have specifier for input and for both" << std::endl;
        1:  580:                free(output);
        1:  581:                free(input);
        1:  582:                free(both);
        1:  583:                return 1;
        -:  584:            }
        -:  585:
        -:  586:            try
        -:  587:            {
        -:  588:                // parse the specifier
       13:  589:                input = parse_connection(optarg);
        -:  590:                // datagram limitations
       11:  591:                if (input->socktype == SOCK_DGRAM && input->host_type == CLIENT)
        2:  592:                    throw std::invalid_argument("Cannot use datagram client as input");
        -:  593:            }
        3:  594:            catch (const std::invalid_argument &e)
        -:  595:            {
        3:  596:                std::cerr << "Error in address argument: " << e.what() << std::endl;
        3:  597:                print_usage(argv[0]);
        3:  598:                free(output);
        3:  599:                free(input);
        3:  600:                free(both);
        3:  601:                return 1;
        -:  602:            }
        -:  603:            // runtime errors occur by getaddrinfo
        1:  604:            catch (const std::runtime_error &e)
        -:  605:            {
        1:  606:                std::cerr << "Error finding hostname: " << e.what() << std::endl;
        1:  607:                print_usage(argv[0]);
        1:  608:                free(output);
        1:  609:                free(input);
        1:  610:                free(both);
        1:  611:                return 1;
        -:  612:            }
        9:  613:            break;
       14:  614:        case 'o':
       14:  615:            if (output != NULL)
        -:  616:            {
        1:  617:                print_usage(argv[0]);
        1:  618:                std::cerr << "Cannot have double specifier for output" << std::endl;
        1:  619:                free(output);
        1:  620:                free(input);
        1:  621:                free(both);
        1:  622:                return 1;
        -:  623:            }
       13:  624:            if (both != NULL)
        -:  625:            {
        1:  626:                print_usage(argv[0]);
        1:  627:                std::cerr << "Cannot have specifier for output and for both" << std::endl;
        1:  628:                free(output);
        1:  629:                free(input);
        1:  630:                free(both);
        1:  631:                return 1;
        -:  632:            }
        -:  633:            try
        -:  634:            {
       12:  635:                output = parse_connection(optarg);
       10:  636:                if (output->socktype == SOCK_DGRAM && output->host_type == SERVER)
        3:  637:                    throw std::invalid_argument("Cannot use datagram server as output");
        -:  638:            }
        4:  639:            catch (const std::invalid_argument &e)
        -:  640:            {
        4:  641:                std::cerr << "Error in address argument: " << e.what() << std::endl;
        4:  642:                print_usage(argv[0]);
        4:  643:                free(output);
        4:  644:                free(input);
        4:  645:                free(both);
        4:  646:                return 1;
        -:  647:            }
        1:  648:            catch (const std::runtime_error &e)
        -:  649:            {
        1:  650:                std::cerr << "Error finding hostname: " << e.what() << std::endl;
        1:  651:                print_usage(argv[0]);
        1:  652:                free(output);
        1:  653:                free(input);
        1:  654:                free(both);
        1:  655:                return 1;
        -:  656:            }
        7:  657:            break;
       26:  658:        case 'b':
       26:  659:            if (both != NULL)
        -:  660:            {
        1:  661:                print_usage(argv[0]);
        1:  662:                std::cerr << "Cannot have double specifier for both" << std::endl;
        1:  663:                free(output);
        1:  664:                free(input);
        1:  665:                free(both);
        1:  666:                return 1;
        -:  667:            }
       25:  668:            if (input != NULL || output != NULL)
        -:  669:            {
        1:  670:                print_usage(argv[0]);
        1:  671:                std::cerr << "Cannot have specifier for both and for input or output" << std::endl;
        1:  672:                free(output);
        1:  673:                free(input);
        1:  674:                free(both);
        1:  675:                return 1;
        -:  676:            }
        -:  677:            try
        -:  678:            {
       24:  679:                both = parse_connection(optarg);
        8:  680:                if (both->socktype == SOCK_DGRAM)
        4:  681:                    throw std::invalid_argument("Cannot use datagram connection as both input and output");
        -:  682:            }
       19:  683:            catch (const std::invalid_argument &e)
        -:  684:            {
       19:  685:                std::cerr << "Error in address argument: " << e.what() << std::endl;
       19:  686:                print_usage(argv[0]);
       19:  687:                free(output);
       19:  688:                free(input);
       19:  689:                free(both);
       19:  690:                return 1;
        -:  691:            }
        1:  692:            catch (const std::runtime_error &e)
        -:  693:            {
        1:  694:                std::cerr << "Error finding hostname: " << e.what() << std::endl;
        1:  695:                print_usage(argv[0]);
        1:  696:                free(output);
        1:  697:                free(input);
        1:  698:                free(both);
        1:  699:                return 1;
        -:  700:            }
        4:  701:            break;
        -:  702:
        1:  703:        case '?':
        1:  704:            print_usage(argv[0]);
        1:  705:            free(output);
        1:  706:            free(input);
        1:  707:            free(both);
        1:  708:            return 1;
    #####:  709:        default:
    #####:  710:            abort();
        -:  711:        }
        -:  712:    }
        -:  713:
        -:  714:    // flush files before duping them
       14:  715:    fflush(stdin);
       14:  716:    fflush(stdout);
        -:  717:    // default fds as standard files
       14:  718:    int input_fd = STDIN_FILENO, output_fd = STDOUT_FILENO;
        -:  719:
        -:  720:    // check if we set a connection for both
       14:  721:    if (both != NULL)
        -:  722:    {
        -:  723:        try
        -:  724:        {
        -:  725:            // set up the connection and use the fd as both
       1*:  726:            input_fd = output_fd = setup_connection(both);
        -:  727:        }
        1:  728:        catch (const std::runtime_error &e)
        -:  729:        {
        1:  730:            std::cerr << "Error opening connection: " << e.what() << std::endl;
        1:  731:            free(output);
        1:  732:            free(input);
        1:  733:            free(both);
        1:  734:            return 1;
        -:  735:        }
        -:  736:    }
        -:  737:
       13:  738:    if (input != NULL)
        -:  739:    {
        -:  740:        try
        -:  741:        {
        -:  742:            // set up the connection and use fd as input
        7:  743:            input_fd = setup_connection(input);
        -:  744:        }
    =====:  745:        catch (const std::runtime_error &e)
        -:  746:        {
    =====:  747:            std::cerr << "Error opening connection: " << e.what() << std::endl;
    =====:  748:            free(output);
    =====:  749:            free(input);
    =====:  750:            free(both);
    =====:  751:            return 1;
        -:  752:        }
        -:  753:    }
        -:  754:
       13:  755:    if (output != NULL)
        -:  756:    {
        -:  757:        try
        -:  758:        {
        -:  759:            // set up the connection and use fd as output
        6:  760:            output_fd = setup_connection(output);
        -:  761:        }
    =====:  762:        catch (const std::runtime_error &e)
        -:  763:        {
    =====:  764:            std::cerr << "Error opening connection: " << e.what() << std::endl;
    =====:  765:            free(output);
    =====:  766:            free(input);
    =====:  767:            free(both);
    =====:  768:            return 1;
        -:  769:        }
        -:  770:    }
        -:  771:
        -:  772:    // free memory allocated by setup_connection or its callees
       13:  773:    free(output);
       13:  774:    free(input);
       13:  775:    free(both);
        -:  776:
        -:  777:    // no -e option, need to pipe input to stdout and stdin to output
       13:  778:    if (command == NULL)
        -:  779:    {
        -:  780:        // run piper(input_fd, STDOUT_FILENO) & piper(STDIN_FILENO, output_fd)
        -:  781:        // piper expects int[2]
        -:  782:        thrd_t input_piper;
        -:  783:        // create an array with the fds
        1:  784:        int input_fds[2] = {input_fd, STDOUT_FILENO};
        -:  785:        // run the piper
        1:  786:        thrd_create(&input_piper, piper, input_fds);
        -:  787:        thrd_t output_piper;
        1:  788:        int output_fds[2] = {STDIN_FILENO, output_fd};
        1:  789:        thrd_create(&output_piper, piper, output_fds);
        -:  790:        int res;
        -:  791:        // join the 2 pipers, they will finish when the connection closes
        1:  792:        thrd_join(input_piper, &res);
        1:  793:        thrd_join(output_piper, &res);
        -:  794:    }
        -:  795:    else
        -:  796:    {
        -:  797:        // we need to run command with stdin and stdout going to input_fd and output_fd
        -:  798:        // so we dup each one to the proper fd
       12:  799:        if (dup2(input_fd, STDIN_FILENO) < 0)
        -:  800:        {
    #####:  801:            perror("Error duping input file descriptor");
    #####:  802:            return 1;
        -:  803:        }
       12:  804:        if (dup2(output_fd, STDOUT_FILENO) < 0)
        -:  805:        {
    #####:  806:            perror("Error duping output file descriptor");
    #####:  807:            return 1;
        -:  808:        }
        -:  809:
        -:  810:        // run the command, error happens if it returned non-zero and set errno
        -:  811:        int wstatus;
      12*:  812:        if ((wstatus = system(command)) != 0 && errno != 0)
        -:  813:        {
    #####:  814:            perror("ERROR: On command execution (system(3))");
    #####:  815:            std::cerr << "INFO: Command was \"" << command << "\"" << std::endl;
    #####:  816:            return 1;
        -:  817:        }
        -:  818:        // if the shell exit status is 127 the executable was not found
       12:  819:        if (WEXITSTATUS(wstatus) == 127)
        -:  820:        {
        1:  821:            std::cerr << "ERROR: Executable not found" << std::endl;
        1:  822:            std::cerr << "INFO: Command was \"" << command << "\"" << std::endl;
        1:  823:            return 1;
        -:  824:        }
        -:  825:    }
        -:  826:
        -:  827:    // clean up all resources
       31:  828:    for (auto &cu : to_cleanup)
        -:  829:    {
       19:  830:        cu->cleanup();
        -:  831:    }
        -:  832:
       12:  833:    return 0;
        -:  834:}
